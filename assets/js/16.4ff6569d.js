(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{585:function(t,a,v){t.exports=v.p+"assets/img/js1.027d9c6f.png"},604:function(t,a,v){"use strict";v.r(a);var r=v(3),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("blockquote",[r("p",[t._v("Interpretation of poetry：\n皓穹 : 指上天。司马相如《封禅文》:“肇自～～兮生民。”")])]),t._v(" "),r("h3",{attrs:{id:"设计模式之道"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计模式之道"}},[t._v("#")]),t._v(" 设计模式之道")]),t._v(" "),r("hr"),t._v(" "),r("h4",{attrs:{id:"设计模式-究竟有着怎样的力量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计模式-究竟有着怎样的力量"}},[t._v("#")]),t._v(" 设计模式，究竟有着怎样的力量?")]),t._v(" "),r("blockquote",[r("p",[t._v("每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。 —— Christopher Alexander")])]),t._v(" "),r("p",[t._v("设计模式是“拿来主义”在软件领域的贯彻实践。和很多人的主观臆断相反，设计模式不是一堆空空如也、晦涩鸡肋的理论，它是一套现成的工具 —— 就好像你想要做饭的时候，会拿起厨具直接烹饪，而不会自己去铸一口锅、磨一把菜刀一样。")]),t._v(" "),r("p",[t._v("用做数学题来打比方，可能大家会更能体会这种概念 —— 我们解题目的时候，往往会用到很多公式/现成的解题方法。比如已知直角三角形两边长，求另一边，我们会直接用勾股定理（我想应该没有人会每求一次边长都自己推一遍勾股定理才用吧）。")]),t._v(" "),r("p",[t._v("识别题目特征 —— catch题目想要考查的知识点 —— 快速在脑海中映射出它对应的解决方法，这个过程在我们学生时代几乎是一个本能的、条件反射一样的脑回路机制。在学习设计模式时，如果各位可以回忆起这种“从映射到默写”的思维方式，相信这个学习过程会是轻松的、自然的。")]),t._v(" "),r("h4",{attrs:{id:"solid设计原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#solid设计原则"}},[t._v("#")]),t._v(" SOLID设计原则")]),t._v(" "),r("blockquote",[r("p",[t._v('"SOLID" 是由罗伯特·C·马丁在 21 世纪早期引入的记忆术首字母缩略字，指代了面向对象编程和面向对象设计的五个基本原则。')])]),t._v(" "),r("p",[t._v("设计原则是设计模式的指导理论，他可以帮助我们规避不良的软件设计。SOLID指代的五个基本原则分别是：")]),t._v(" "),r("ol",[r("li",[t._v("单一开放原则（Single Responsibility Principle）")]),t._v(" "),r("li",[t._v("开放封闭原则（Opened Closed Principle）")]),t._v(" "),r("li",[t._v("里式替换原则（Liskov Substitution Principle）")]),t._v(" "),r("li",[t._v("接口隔离原则（Interface Segregation Principle）")]),t._v(" "),r("li",[t._v("依赖反转原则（Dependency Inversion Principle）")])]),t._v(" "),r("h4",{attrs:{id:"设计模式的核心思想-封装变化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的核心思想-封装变化"}},[t._v("#")]),t._v(" 设计模式的核心思想--封装变化")]),t._v(" "),r("p",[t._v("设计模式出现的背景，是软件设计的复杂度日益飙升。软件设计越来越复杂的“罪魁祸首”，就是变化。")]),t._v(" "),r("p",[t._v("在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响"),r("strong",[t._v("最小化 --将变与不变分离，确保变化的部分灵活，不变的部分稳定。")])]),t._v(" "),r("p",[t._v("这个过程，就叫“封装变化”；这样的代码，就是我们所谓的“健壮”的代码，他可以经得起变化的考验。而设计模式出现的意义，就是帮我们写出这样的代码。")]),t._v(" "),r("h3",{attrs:{id:"设计模式的术"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的术"}},[t._v("#")]),t._v(" 设计模式的术")]),t._v(" "),r("p",[t._v("所谓“术”，其实就是指二十年前"),r("code",[t._v("GOF")]),t._v("提出的最经典的23种设计模式。二十年前，四位程序员前辈（"),r("code",[t._v("Erich Gamma, Richard Helm, Ralph Johnson & John Vlissides")]),t._v("）通过编写《设计模式：可复用面向对象软件的基础》这本书，阐述了设计模式领域的开创性成果。在这本书中，将23种设计模式按照“创建型”、“行为型”和“结构型”进行划分：")]),t._v(" "),r("p",[r("img",{attrs:{src:v(585),alt:"设计模式"}})]),t._v(" "),r("p",[t._v("设计模式的核心思想，就是“封装变化”。无论是创建型、结构型还是行为型，这些具体的设计模式都是在用自己的方式去封装不同类型的变化 —— 创建型模式封装了创建对象过程中的变化；工厂模式，它做的事情就是将创建对象的过程抽离；结构型模式封装的是对象之间组合方式的变化，目的在于灵活地表达对象间的配合与依赖关系；而行为型模式则将是对象千变万化的行为进行抽离，确保我们能够更安全、更方便地对行为进行更改。")]),t._v(" "),r("p",[t._v("封装变化，封装的正是软件中那些不稳定的要素，它是一种防患于未然的行为 —— 提前抽离了变化，就为后续的拓展提供了无限的可能性，如此，我们才能做到在变化到来的时候从容不迫。")]),t._v(" "),r("h3",{attrs:{id:"从-java-c-到-javascript-的迁移"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从-java-c-到-javascript-的迁移"}},[t._v("#")]),t._v(" 从 Java/C++ 到 JavaScript 的迁移")]),t._v(" "),r("p",[t._v("设计模式迁移到 JavaScript，不仅仅是从一类语言到另一类语言这么简单。强类型语言不仅和 JavaScript 之间存在着基本语法的差异，还存在着应用场景的差异。")])])}),[],!1,null,null,null);a.default=e.exports}}]);